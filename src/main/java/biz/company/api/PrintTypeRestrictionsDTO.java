//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.4 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2011.10.19 at 07:09:03 PM CEST 
//


package biz.company.api;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlType;
import org.jvnet.jaxb2_commons.lang.CopyStrategy;
import org.jvnet.jaxb2_commons.lang.CopyTo;
import org.jvnet.jaxb2_commons.lang.Equals;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy;
import org.jvnet.jaxb2_commons.lang.HashCode;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBCopyStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBMergeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBToStringStrategy;
import org.jvnet.jaxb2_commons.lang.MergeFrom;
import org.jvnet.jaxb2_commons.lang.MergeStrategy;
import org.jvnet.jaxb2_commons.lang.ToString;
import org.jvnet.jaxb2_commons.lang.ToStringStrategy;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;


/**
 * <p>Java class for printTypeRestrictionsDTO complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="printTypeRestrictionsDTO">
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element name="colorSpace" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         &lt;element name="whiteSupported" type="{http://www.w3.org/2001/XMLSchema}boolean"/>
 *         &lt;element name="transparencySupported" type="{http://www.w3.org/2001/XMLSchema}boolean"/>
 *         &lt;element name="scaleability" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         &lt;element name="printableAlongWithPrintTypes" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;sequence>
 *                   &lt;element name="printableAlongWithPrintType" type="{http://api.company.biz}reference" maxOccurs="unbounded" minOccurs="0"/>
 *                 &lt;/sequence>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="printableAbovePrintTypes" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;sequence>
 *                   &lt;element name="printableAbovePrintType" type="{http://api.company.biz}reference" maxOccurs="unbounded" minOccurs="0"/>
 *                 &lt;/sequence>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="maxPrintColorLayers" type="{http://www.w3.org/2001/XMLSchema}int"/>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "printTypeRestrictionsDTO", propOrder = {
    "colorSpace",
    "whiteSupported",
    "transparencySupported",
    "scaleability",
    "printableAlongWithPrintTypes",
    "printableAbovePrintTypes",
    "maxPrintColorLayers"
})
public class PrintTypeRestrictionsDTO
    implements Cloneable, CopyTo, Equals, HashCode, MergeFrom, ToString
{

    protected String colorSpace;
    protected boolean whiteSupported;
    protected boolean transparencySupported;
    protected String scaleability;
    protected PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes printableAlongWithPrintTypes;
    protected PrintTypeRestrictionsDTO.PrintableAbovePrintTypes printableAbovePrintTypes;
    protected int maxPrintColorLayers;

    /**
     * Gets the value of the colorSpace property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getColorSpace() {
        return colorSpace;
    }

    /**
     * Sets the value of the colorSpace property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setColorSpace(String value) {
        this.colorSpace = value;
    }

    /**
     * Gets the value of the whiteSupported property.
     * 
     */
    public boolean isWhiteSupported() {
        return whiteSupported;
    }

    /**
     * Sets the value of the whiteSupported property.
     * 
     */
    public void setWhiteSupported(boolean value) {
        this.whiteSupported = value;
    }

    /**
     * Gets the value of the transparencySupported property.
     * 
     */
    public boolean isTransparencySupported() {
        return transparencySupported;
    }

    /**
     * Sets the value of the transparencySupported property.
     * 
     */
    public void setTransparencySupported(boolean value) {
        this.transparencySupported = value;
    }

    /**
     * Gets the value of the scaleability property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getScaleability() {
        return scaleability;
    }

    /**
     * Sets the value of the scaleability property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setScaleability(String value) {
        this.scaleability = value;
    }

    /**
     * Gets the value of the printableAlongWithPrintTypes property.
     * 
     * @return
     *     possible object is
     *     {@link PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes }
     *     
     */
    public PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes getPrintableAlongWithPrintTypes() {
        return printableAlongWithPrintTypes;
    }

    /**
     * Sets the value of the printableAlongWithPrintTypes property.
     * 
     * @param value
     *     allowed object is
     *     {@link PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes }
     *     
     */
    public void setPrintableAlongWithPrintTypes(PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes value) {
        this.printableAlongWithPrintTypes = value;
    }

    /**
     * Gets the value of the printableAbovePrintTypes property.
     * 
     * @return
     *     possible object is
     *     {@link PrintTypeRestrictionsDTO.PrintableAbovePrintTypes }
     *     
     */
    public PrintTypeRestrictionsDTO.PrintableAbovePrintTypes getPrintableAbovePrintTypes() {
        return printableAbovePrintTypes;
    }

    /**
     * Sets the value of the printableAbovePrintTypes property.
     * 
     * @param value
     *     allowed object is
     *     {@link PrintTypeRestrictionsDTO.PrintableAbovePrintTypes }
     *     
     */
    public void setPrintableAbovePrintTypes(PrintTypeRestrictionsDTO.PrintableAbovePrintTypes value) {
        this.printableAbovePrintTypes = value;
    }

    /**
     * Gets the value of the maxPrintColorLayers property.
     * 
     */
    public int getMaxPrintColorLayers() {
        return maxPrintColorLayers;
    }

    /**
     * Sets the value of the maxPrintColorLayers property.
     * 
     */
    public void setMaxPrintColorLayers(int value) {
        this.maxPrintColorLayers = value;
    }

    public String toString() {
        final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        {
            String theColorSpace;
            theColorSpace = this.getColorSpace();
            strategy.appendField(locator, this, "colorSpace", buffer, theColorSpace);
        }
        {
            boolean theWhiteSupported;
            theWhiteSupported = (true?this.isWhiteSupported():false);
            strategy.appendField(locator, this, "whiteSupported", buffer, theWhiteSupported);
        }
        {
            boolean theTransparencySupported;
            theTransparencySupported = (true?this.isTransparencySupported():false);
            strategy.appendField(locator, this, "transparencySupported", buffer, theTransparencySupported);
        }
        {
            String theScaleability;
            theScaleability = this.getScaleability();
            strategy.appendField(locator, this, "scaleability", buffer, theScaleability);
        }
        {
            PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes thePrintableAlongWithPrintTypes;
            thePrintableAlongWithPrintTypes = this.getPrintableAlongWithPrintTypes();
            strategy.appendField(locator, this, "printableAlongWithPrintTypes", buffer, thePrintableAlongWithPrintTypes);
        }
        {
            PrintTypeRestrictionsDTO.PrintableAbovePrintTypes thePrintableAbovePrintTypes;
            thePrintableAbovePrintTypes = this.getPrintableAbovePrintTypes();
            strategy.appendField(locator, this, "printableAbovePrintTypes", buffer, thePrintableAbovePrintTypes);
        }
        {
            int theMaxPrintColorLayers;
            theMaxPrintColorLayers = (true?this.getMaxPrintColorLayers(): 0);
            strategy.appendField(locator, this, "maxPrintColorLayers", buffer, theMaxPrintColorLayers);
        }
        return buffer;
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
        if (!(object instanceof PrintTypeRestrictionsDTO)) {
            return false;
        }
        if (this == object) {
            return true;
        }
        final PrintTypeRestrictionsDTO that = ((PrintTypeRestrictionsDTO) object);
        {
            String lhsColorSpace;
            lhsColorSpace = this.getColorSpace();
            String rhsColorSpace;
            rhsColorSpace = that.getColorSpace();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "colorSpace", lhsColorSpace), LocatorUtils.property(thatLocator, "colorSpace", rhsColorSpace), lhsColorSpace, rhsColorSpace)) {
                return false;
            }
        }
        {
            boolean lhsWhiteSupported;
            lhsWhiteSupported = (true?this.isWhiteSupported():false);
            boolean rhsWhiteSupported;
            rhsWhiteSupported = (true?that.isWhiteSupported():false);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "whiteSupported", lhsWhiteSupported), LocatorUtils.property(thatLocator, "whiteSupported", rhsWhiteSupported), lhsWhiteSupported, rhsWhiteSupported)) {
                return false;
            }
        }
        {
            boolean lhsTransparencySupported;
            lhsTransparencySupported = (true?this.isTransparencySupported():false);
            boolean rhsTransparencySupported;
            rhsTransparencySupported = (true?that.isTransparencySupported():false);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "transparencySupported", lhsTransparencySupported), LocatorUtils.property(thatLocator, "transparencySupported", rhsTransparencySupported), lhsTransparencySupported, rhsTransparencySupported)) {
                return false;
            }
        }
        {
            String lhsScaleability;
            lhsScaleability = this.getScaleability();
            String rhsScaleability;
            rhsScaleability = that.getScaleability();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "scaleability", lhsScaleability), LocatorUtils.property(thatLocator, "scaleability", rhsScaleability), lhsScaleability, rhsScaleability)) {
                return false;
            }
        }
        {
            PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes lhsPrintableAlongWithPrintTypes;
            lhsPrintableAlongWithPrintTypes = this.getPrintableAlongWithPrintTypes();
            PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes rhsPrintableAlongWithPrintTypes;
            rhsPrintableAlongWithPrintTypes = that.getPrintableAlongWithPrintTypes();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "printableAlongWithPrintTypes", lhsPrintableAlongWithPrintTypes), LocatorUtils.property(thatLocator, "printableAlongWithPrintTypes", rhsPrintableAlongWithPrintTypes), lhsPrintableAlongWithPrintTypes, rhsPrintableAlongWithPrintTypes)) {
                return false;
            }
        }
        {
            PrintTypeRestrictionsDTO.PrintableAbovePrintTypes lhsPrintableAbovePrintTypes;
            lhsPrintableAbovePrintTypes = this.getPrintableAbovePrintTypes();
            PrintTypeRestrictionsDTO.PrintableAbovePrintTypes rhsPrintableAbovePrintTypes;
            rhsPrintableAbovePrintTypes = that.getPrintableAbovePrintTypes();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "printableAbovePrintTypes", lhsPrintableAbovePrintTypes), LocatorUtils.property(thatLocator, "printableAbovePrintTypes", rhsPrintableAbovePrintTypes), lhsPrintableAbovePrintTypes, rhsPrintableAbovePrintTypes)) {
                return false;
            }
        }
        {
            int lhsMaxPrintColorLayers;
            lhsMaxPrintColorLayers = (true?this.getMaxPrintColorLayers(): 0);
            int rhsMaxPrintColorLayers;
            rhsMaxPrintColorLayers = (true?that.getMaxPrintColorLayers(): 0);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "maxPrintColorLayers", lhsMaxPrintColorLayers), LocatorUtils.property(thatLocator, "maxPrintColorLayers", rhsMaxPrintColorLayers), lhsMaxPrintColorLayers, rhsMaxPrintColorLayers)) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
        int currentHashCode = 1;
        {
            String theColorSpace;
            theColorSpace = this.getColorSpace();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "colorSpace", theColorSpace), currentHashCode, theColorSpace);
        }
        {
            boolean theWhiteSupported;
            theWhiteSupported = (true?this.isWhiteSupported():false);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "whiteSupported", theWhiteSupported), currentHashCode, theWhiteSupported);
        }
        {
            boolean theTransparencySupported;
            theTransparencySupported = (true?this.isTransparencySupported():false);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "transparencySupported", theTransparencySupported), currentHashCode, theTransparencySupported);
        }
        {
            String theScaleability;
            theScaleability = this.getScaleability();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "scaleability", theScaleability), currentHashCode, theScaleability);
        }
        {
            PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes thePrintableAlongWithPrintTypes;
            thePrintableAlongWithPrintTypes = this.getPrintableAlongWithPrintTypes();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "printableAlongWithPrintTypes", thePrintableAlongWithPrintTypes), currentHashCode, thePrintableAlongWithPrintTypes);
        }
        {
            PrintTypeRestrictionsDTO.PrintableAbovePrintTypes thePrintableAbovePrintTypes;
            thePrintableAbovePrintTypes = this.getPrintableAbovePrintTypes();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "printableAbovePrintTypes", thePrintableAbovePrintTypes), currentHashCode, thePrintableAbovePrintTypes);
        }
        {
            int theMaxPrintColorLayers;
            theMaxPrintColorLayers = (true?this.getMaxPrintColorLayers(): 0);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "maxPrintColorLayers", theMaxPrintColorLayers), currentHashCode, theMaxPrintColorLayers);
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

    public Object clone() {
        return copyTo(createNewInstance());
    }

    public Object copyTo(Object target) {
        final CopyStrategy strategy = JAXBCopyStrategy.INSTANCE;
        return copyTo(null, target, strategy);
    }

    public Object copyTo(ObjectLocator locator, Object target, CopyStrategy strategy) {
        final Object draftCopy = ((target == null)?createNewInstance():target);
        if (draftCopy instanceof PrintTypeRestrictionsDTO) {
            final PrintTypeRestrictionsDTO copy = ((PrintTypeRestrictionsDTO) draftCopy);
            if (this.colorSpace!= null) {
                String sourceColorSpace;
                sourceColorSpace = this.getColorSpace();
                String copyColorSpace = ((String) strategy.copy(LocatorUtils.property(locator, "colorSpace", sourceColorSpace), sourceColorSpace));
                copy.setColorSpace(copyColorSpace);
            } else {
                copy.colorSpace = null;
            }
            boolean sourceWhiteSupported;
            sourceWhiteSupported = (true?this.isWhiteSupported():false);
            boolean copyWhiteSupported = strategy.copy(LocatorUtils.property(locator, "whiteSupported", sourceWhiteSupported), sourceWhiteSupported);
            copy.setWhiteSupported(copyWhiteSupported);
            boolean sourceTransparencySupported;
            sourceTransparencySupported = (true?this.isTransparencySupported():false);
            boolean copyTransparencySupported = strategy.copy(LocatorUtils.property(locator, "transparencySupported", sourceTransparencySupported), sourceTransparencySupported);
            copy.setTransparencySupported(copyTransparencySupported);
            if (this.scaleability!= null) {
                String sourceScaleability;
                sourceScaleability = this.getScaleability();
                String copyScaleability = ((String) strategy.copy(LocatorUtils.property(locator, "scaleability", sourceScaleability), sourceScaleability));
                copy.setScaleability(copyScaleability);
            } else {
                copy.scaleability = null;
            }
            if (this.printableAlongWithPrintTypes!= null) {
                PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes sourcePrintableAlongWithPrintTypes;
                sourcePrintableAlongWithPrintTypes = this.getPrintableAlongWithPrintTypes();
                PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes copyPrintableAlongWithPrintTypes = ((PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes) strategy.copy(LocatorUtils.property(locator, "printableAlongWithPrintTypes", sourcePrintableAlongWithPrintTypes), sourcePrintableAlongWithPrintTypes));
                copy.setPrintableAlongWithPrintTypes(copyPrintableAlongWithPrintTypes);
            } else {
                copy.printableAlongWithPrintTypes = null;
            }
            if (this.printableAbovePrintTypes!= null) {
                PrintTypeRestrictionsDTO.PrintableAbovePrintTypes sourcePrintableAbovePrintTypes;
                sourcePrintableAbovePrintTypes = this.getPrintableAbovePrintTypes();
                PrintTypeRestrictionsDTO.PrintableAbovePrintTypes copyPrintableAbovePrintTypes = ((PrintTypeRestrictionsDTO.PrintableAbovePrintTypes) strategy.copy(LocatorUtils.property(locator, "printableAbovePrintTypes", sourcePrintableAbovePrintTypes), sourcePrintableAbovePrintTypes));
                copy.setPrintableAbovePrintTypes(copyPrintableAbovePrintTypes);
            } else {
                copy.printableAbovePrintTypes = null;
            }
            int sourceMaxPrintColorLayers;
            sourceMaxPrintColorLayers = (true?this.getMaxPrintColorLayers(): 0);
            int copyMaxPrintColorLayers = strategy.copy(LocatorUtils.property(locator, "maxPrintColorLayers", sourceMaxPrintColorLayers), sourceMaxPrintColorLayers);
            copy.setMaxPrintColorLayers(copyMaxPrintColorLayers);
        }
        return draftCopy;
    }

    public Object createNewInstance() {
        return new PrintTypeRestrictionsDTO();
    }

    public void mergeFrom(Object left, Object right) {
        final MergeStrategy strategy = JAXBMergeStrategy.INSTANCE;
        mergeFrom(null, null, left, right, strategy);
    }

    public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy strategy) {
        if (right instanceof PrintTypeRestrictionsDTO) {
            final PrintTypeRestrictionsDTO target = this;
            final PrintTypeRestrictionsDTO leftObject = ((PrintTypeRestrictionsDTO) left);
            final PrintTypeRestrictionsDTO rightObject = ((PrintTypeRestrictionsDTO) right);
            {
                String lhsColorSpace;
                lhsColorSpace = leftObject.getColorSpace();
                String rhsColorSpace;
                rhsColorSpace = rightObject.getColorSpace();
                String mergedColorSpace = ((String) strategy.merge(LocatorUtils.property(leftLocator, "colorSpace", lhsColorSpace), LocatorUtils.property(rightLocator, "colorSpace", rhsColorSpace), lhsColorSpace, rhsColorSpace));
                target.setColorSpace(mergedColorSpace);
            }
            {
                boolean lhsWhiteSupported;
                lhsWhiteSupported = (true?leftObject.isWhiteSupported():false);
                boolean rhsWhiteSupported;
                rhsWhiteSupported = (true?rightObject.isWhiteSupported():false);
                boolean mergedWhiteSupported = ((boolean) strategy.merge(LocatorUtils.property(leftLocator, "whiteSupported", lhsWhiteSupported), LocatorUtils.property(rightLocator, "whiteSupported", rhsWhiteSupported), lhsWhiteSupported, rhsWhiteSupported));
                target.setWhiteSupported(mergedWhiteSupported);
            }
            {
                boolean lhsTransparencySupported;
                lhsTransparencySupported = (true?leftObject.isTransparencySupported():false);
                boolean rhsTransparencySupported;
                rhsTransparencySupported = (true?rightObject.isTransparencySupported():false);
                boolean mergedTransparencySupported = ((boolean) strategy.merge(LocatorUtils.property(leftLocator, "transparencySupported", lhsTransparencySupported), LocatorUtils.property(rightLocator, "transparencySupported", rhsTransparencySupported), lhsTransparencySupported, rhsTransparencySupported));
                target.setTransparencySupported(mergedTransparencySupported);
            }
            {
                String lhsScaleability;
                lhsScaleability = leftObject.getScaleability();
                String rhsScaleability;
                rhsScaleability = rightObject.getScaleability();
                String mergedScaleability = ((String) strategy.merge(LocatorUtils.property(leftLocator, "scaleability", lhsScaleability), LocatorUtils.property(rightLocator, "scaleability", rhsScaleability), lhsScaleability, rhsScaleability));
                target.setScaleability(mergedScaleability);
            }
            {
                PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes lhsPrintableAlongWithPrintTypes;
                lhsPrintableAlongWithPrintTypes = leftObject.getPrintableAlongWithPrintTypes();
                PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes rhsPrintableAlongWithPrintTypes;
                rhsPrintableAlongWithPrintTypes = rightObject.getPrintableAlongWithPrintTypes();
                PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes mergedPrintableAlongWithPrintTypes = ((PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes) strategy.merge(LocatorUtils.property(leftLocator, "printableAlongWithPrintTypes", lhsPrintableAlongWithPrintTypes), LocatorUtils.property(rightLocator, "printableAlongWithPrintTypes", rhsPrintableAlongWithPrintTypes), lhsPrintableAlongWithPrintTypes, rhsPrintableAlongWithPrintTypes));
                target.setPrintableAlongWithPrintTypes(mergedPrintableAlongWithPrintTypes);
            }
            {
                PrintTypeRestrictionsDTO.PrintableAbovePrintTypes lhsPrintableAbovePrintTypes;
                lhsPrintableAbovePrintTypes = leftObject.getPrintableAbovePrintTypes();
                PrintTypeRestrictionsDTO.PrintableAbovePrintTypes rhsPrintableAbovePrintTypes;
                rhsPrintableAbovePrintTypes = rightObject.getPrintableAbovePrintTypes();
                PrintTypeRestrictionsDTO.PrintableAbovePrintTypes mergedPrintableAbovePrintTypes = ((PrintTypeRestrictionsDTO.PrintableAbovePrintTypes) strategy.merge(LocatorUtils.property(leftLocator, "printableAbovePrintTypes", lhsPrintableAbovePrintTypes), LocatorUtils.property(rightLocator, "printableAbovePrintTypes", rhsPrintableAbovePrintTypes), lhsPrintableAbovePrintTypes, rhsPrintableAbovePrintTypes));
                target.setPrintableAbovePrintTypes(mergedPrintableAbovePrintTypes);
            }
            {
                int lhsMaxPrintColorLayers;
                lhsMaxPrintColorLayers = (true?leftObject.getMaxPrintColorLayers(): 0);
                int rhsMaxPrintColorLayers;
                rhsMaxPrintColorLayers = (true?rightObject.getMaxPrintColorLayers(): 0);
                int mergedMaxPrintColorLayers = ((int) strategy.merge(LocatorUtils.property(leftLocator, "maxPrintColorLayers", lhsMaxPrintColorLayers), LocatorUtils.property(rightLocator, "maxPrintColorLayers", rhsMaxPrintColorLayers), lhsMaxPrintColorLayers, rhsMaxPrintColorLayers));
                target.setMaxPrintColorLayers(mergedMaxPrintColorLayers);
            }
        }
    }

    public PrintTypeRestrictionsDTO withColorSpace(String value) {
        setColorSpace(value);
        return this;
    }

    public PrintTypeRestrictionsDTO withWhiteSupported(boolean value) {
        setWhiteSupported(value);
        return this;
    }

    public PrintTypeRestrictionsDTO withTransparencySupported(boolean value) {
        setTransparencySupported(value);
        return this;
    }

    public PrintTypeRestrictionsDTO withScaleability(String value) {
        setScaleability(value);
        return this;
    }

    public PrintTypeRestrictionsDTO withPrintableAlongWithPrintTypes(PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes value) {
        setPrintableAlongWithPrintTypes(value);
        return this;
    }

    public PrintTypeRestrictionsDTO withPrintableAbovePrintTypes(PrintTypeRestrictionsDTO.PrintableAbovePrintTypes value) {
        setPrintableAbovePrintTypes(value);
        return this;
    }

    public PrintTypeRestrictionsDTO withMaxPrintColorLayers(int value) {
        setMaxPrintColorLayers(value);
        return this;
    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;sequence>
     *         &lt;element name="printableAbovePrintType" type="{http://api.company.biz}reference" maxOccurs="unbounded" minOccurs="0"/>
     *       &lt;/sequence>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "printableAbovePrintType"
    })
    public static class PrintableAbovePrintTypes
        implements Cloneable, CopyTo, Equals, HashCode, MergeFrom, ToString
    {

        protected List<Reference> printableAbovePrintType;

        /**
         * Gets the value of the printableAbovePrintType property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the printableAbovePrintType property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getPrintableAbovePrintType().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Reference }
         * 
         * 
         */
        public List<Reference> getPrintableAbovePrintType() {
            if (printableAbovePrintType == null) {
                printableAbovePrintType = new ArrayList<Reference>();
            }
            return this.printableAbovePrintType;
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                List<Reference> thePrintableAbovePrintType;
                thePrintableAbovePrintType = (((this.printableAbovePrintType!= null)&&(!this.printableAbovePrintType.isEmpty()))?this.getPrintableAbovePrintType():null);
                strategy.appendField(locator, this, "printableAbovePrintType", buffer, thePrintableAbovePrintType);
            }
            return buffer;
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof PrintTypeRestrictionsDTO.PrintableAbovePrintTypes)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final PrintTypeRestrictionsDTO.PrintableAbovePrintTypes that = ((PrintTypeRestrictionsDTO.PrintableAbovePrintTypes) object);
            {
                List<Reference> lhsPrintableAbovePrintType;
                lhsPrintableAbovePrintType = (((this.printableAbovePrintType!= null)&&(!this.printableAbovePrintType.isEmpty()))?this.getPrintableAbovePrintType():null);
                List<Reference> rhsPrintableAbovePrintType;
                rhsPrintableAbovePrintType = (((that.printableAbovePrintType!= null)&&(!that.printableAbovePrintType.isEmpty()))?that.getPrintableAbovePrintType():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "printableAbovePrintType", lhsPrintableAbovePrintType), LocatorUtils.property(thatLocator, "printableAbovePrintType", rhsPrintableAbovePrintType), lhsPrintableAbovePrintType, rhsPrintableAbovePrintType)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
            return equals(null, null, object, strategy);
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                List<Reference> thePrintableAbovePrintType;
                thePrintableAbovePrintType = (((this.printableAbovePrintType!= null)&&(!this.printableAbovePrintType.isEmpty()))?this.getPrintableAbovePrintType():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "printableAbovePrintType", thePrintableAbovePrintType), currentHashCode, thePrintableAbovePrintType);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public Object clone() {
            return copyTo(createNewInstance());
        }

        public Object copyTo(Object target) {
            final CopyStrategy strategy = JAXBCopyStrategy.INSTANCE;
            return copyTo(null, target, strategy);
        }

        public Object copyTo(ObjectLocator locator, Object target, CopyStrategy strategy) {
            final Object draftCopy = ((target == null)?createNewInstance():target);
            if (draftCopy instanceof PrintTypeRestrictionsDTO.PrintableAbovePrintTypes) {
                final PrintTypeRestrictionsDTO.PrintableAbovePrintTypes copy = ((PrintTypeRestrictionsDTO.PrintableAbovePrintTypes) draftCopy);
                if ((this.printableAbovePrintType!= null)&&(!this.printableAbovePrintType.isEmpty())) {
                    List<Reference> sourcePrintableAbovePrintType;
                    sourcePrintableAbovePrintType = (((this.printableAbovePrintType!= null)&&(!this.printableAbovePrintType.isEmpty()))?this.getPrintableAbovePrintType():null);
                    @SuppressWarnings("unchecked")
                    List<Reference> copyPrintableAbovePrintType = ((List<Reference> ) strategy.copy(LocatorUtils.property(locator, "printableAbovePrintType", sourcePrintableAbovePrintType), sourcePrintableAbovePrintType));
                    copy.printableAbovePrintType = null;
                    if (copyPrintableAbovePrintType!= null) {
                        List<Reference> uniquePrintableAbovePrintTypel = copy.getPrintableAbovePrintType();
                        uniquePrintableAbovePrintTypel.addAll(copyPrintableAbovePrintType);
                    }
                } else {
                    copy.printableAbovePrintType = null;
                }
            }
            return draftCopy;
        }

        public Object createNewInstance() {
            return new PrintTypeRestrictionsDTO.PrintableAbovePrintTypes();
        }

        public void mergeFrom(Object left, Object right) {
            final MergeStrategy strategy = JAXBMergeStrategy.INSTANCE;
            mergeFrom(null, null, left, right, strategy);
        }

        public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy strategy) {
            if (right instanceof PrintTypeRestrictionsDTO.PrintableAbovePrintTypes) {
                final PrintTypeRestrictionsDTO.PrintableAbovePrintTypes target = this;
                final PrintTypeRestrictionsDTO.PrintableAbovePrintTypes leftObject = ((PrintTypeRestrictionsDTO.PrintableAbovePrintTypes) left);
                final PrintTypeRestrictionsDTO.PrintableAbovePrintTypes rightObject = ((PrintTypeRestrictionsDTO.PrintableAbovePrintTypes) right);
                {
                    List<Reference> lhsPrintableAbovePrintType;
                    lhsPrintableAbovePrintType = (((leftObject.printableAbovePrintType!= null)&&(!leftObject.printableAbovePrintType.isEmpty()))?leftObject.getPrintableAbovePrintType():null);
                    List<Reference> rhsPrintableAbovePrintType;
                    rhsPrintableAbovePrintType = (((rightObject.printableAbovePrintType!= null)&&(!rightObject.printableAbovePrintType.isEmpty()))?rightObject.getPrintableAbovePrintType():null);
                    List<Reference> mergedPrintableAbovePrintType = ((List<Reference> ) strategy.merge(LocatorUtils.property(leftLocator, "printableAbovePrintType", lhsPrintableAbovePrintType), LocatorUtils.property(rightLocator, "printableAbovePrintType", rhsPrintableAbovePrintType), lhsPrintableAbovePrintType, rhsPrintableAbovePrintType));
                    target.printableAbovePrintType = null;
                    if (mergedPrintableAbovePrintType!= null) {
                        List<Reference> uniquePrintableAbovePrintTypel = target.getPrintableAbovePrintType();
                        uniquePrintableAbovePrintTypel.addAll(mergedPrintableAbovePrintType);
                    }
                }
            }
        }

        public PrintTypeRestrictionsDTO.PrintableAbovePrintTypes withPrintableAbovePrintType(Reference... values) {
            if (values!= null) {
                for (Reference value: values) {
                    getPrintableAbovePrintType().add(value);
                }
            }
            return this;
        }

        public PrintTypeRestrictionsDTO.PrintableAbovePrintTypes withPrintableAbovePrintType(Collection<Reference> values) {
            if (values!= null) {
                getPrintableAbovePrintType().addAll(values);
            }
            return this;
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;sequence>
     *         &lt;element name="printableAlongWithPrintType" type="{http://api.company.biz}reference" maxOccurs="unbounded" minOccurs="0"/>
     *       &lt;/sequence>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "printableAlongWithPrintType"
    })
    public static class PrintableAlongWithPrintTypes
        implements Cloneable, CopyTo, Equals, HashCode, MergeFrom, ToString
    {

        protected List<Reference> printableAlongWithPrintType;

        /**
         * Gets the value of the printableAlongWithPrintType property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the printableAlongWithPrintType property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getPrintableAlongWithPrintType().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Reference }
         * 
         * 
         */
        public List<Reference> getPrintableAlongWithPrintType() {
            if (printableAlongWithPrintType == null) {
                printableAlongWithPrintType = new ArrayList<Reference>();
            }
            return this.printableAlongWithPrintType;
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                List<Reference> thePrintableAlongWithPrintType;
                thePrintableAlongWithPrintType = (((this.printableAlongWithPrintType!= null)&&(!this.printableAlongWithPrintType.isEmpty()))?this.getPrintableAlongWithPrintType():null);
                strategy.appendField(locator, this, "printableAlongWithPrintType", buffer, thePrintableAlongWithPrintType);
            }
            return buffer;
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes that = ((PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes) object);
            {
                List<Reference> lhsPrintableAlongWithPrintType;
                lhsPrintableAlongWithPrintType = (((this.printableAlongWithPrintType!= null)&&(!this.printableAlongWithPrintType.isEmpty()))?this.getPrintableAlongWithPrintType():null);
                List<Reference> rhsPrintableAlongWithPrintType;
                rhsPrintableAlongWithPrintType = (((that.printableAlongWithPrintType!= null)&&(!that.printableAlongWithPrintType.isEmpty()))?that.getPrintableAlongWithPrintType():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "printableAlongWithPrintType", lhsPrintableAlongWithPrintType), LocatorUtils.property(thatLocator, "printableAlongWithPrintType", rhsPrintableAlongWithPrintType), lhsPrintableAlongWithPrintType, rhsPrintableAlongWithPrintType)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
            return equals(null, null, object, strategy);
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                List<Reference> thePrintableAlongWithPrintType;
                thePrintableAlongWithPrintType = (((this.printableAlongWithPrintType!= null)&&(!this.printableAlongWithPrintType.isEmpty()))?this.getPrintableAlongWithPrintType():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "printableAlongWithPrintType", thePrintableAlongWithPrintType), currentHashCode, thePrintableAlongWithPrintType);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public Object clone() {
            return copyTo(createNewInstance());
        }

        public Object copyTo(Object target) {
            final CopyStrategy strategy = JAXBCopyStrategy.INSTANCE;
            return copyTo(null, target, strategy);
        }

        public Object copyTo(ObjectLocator locator, Object target, CopyStrategy strategy) {
            final Object draftCopy = ((target == null)?createNewInstance():target);
            if (draftCopy instanceof PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes) {
                final PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes copy = ((PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes) draftCopy);
                if ((this.printableAlongWithPrintType!= null)&&(!this.printableAlongWithPrintType.isEmpty())) {
                    List<Reference> sourcePrintableAlongWithPrintType;
                    sourcePrintableAlongWithPrintType = (((this.printableAlongWithPrintType!= null)&&(!this.printableAlongWithPrintType.isEmpty()))?this.getPrintableAlongWithPrintType():null);
                    @SuppressWarnings("unchecked")
                    List<Reference> copyPrintableAlongWithPrintType = ((List<Reference> ) strategy.copy(LocatorUtils.property(locator, "printableAlongWithPrintType", sourcePrintableAlongWithPrintType), sourcePrintableAlongWithPrintType));
                    copy.printableAlongWithPrintType = null;
                    if (copyPrintableAlongWithPrintType!= null) {
                        List<Reference> uniquePrintableAlongWithPrintTypel = copy.getPrintableAlongWithPrintType();
                        uniquePrintableAlongWithPrintTypel.addAll(copyPrintableAlongWithPrintType);
                    }
                } else {
                    copy.printableAlongWithPrintType = null;
                }
            }
            return draftCopy;
        }

        public Object createNewInstance() {
            return new PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes();
        }

        public void mergeFrom(Object left, Object right) {
            final MergeStrategy strategy = JAXBMergeStrategy.INSTANCE;
            mergeFrom(null, null, left, right, strategy);
        }

        public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy strategy) {
            if (right instanceof PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes) {
                final PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes target = this;
                final PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes leftObject = ((PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes) left);
                final PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes rightObject = ((PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes) right);
                {
                    List<Reference> lhsPrintableAlongWithPrintType;
                    lhsPrintableAlongWithPrintType = (((leftObject.printableAlongWithPrintType!= null)&&(!leftObject.printableAlongWithPrintType.isEmpty()))?leftObject.getPrintableAlongWithPrintType():null);
                    List<Reference> rhsPrintableAlongWithPrintType;
                    rhsPrintableAlongWithPrintType = (((rightObject.printableAlongWithPrintType!= null)&&(!rightObject.printableAlongWithPrintType.isEmpty()))?rightObject.getPrintableAlongWithPrintType():null);
                    List<Reference> mergedPrintableAlongWithPrintType = ((List<Reference> ) strategy.merge(LocatorUtils.property(leftLocator, "printableAlongWithPrintType", lhsPrintableAlongWithPrintType), LocatorUtils.property(rightLocator, "printableAlongWithPrintType", rhsPrintableAlongWithPrintType), lhsPrintableAlongWithPrintType, rhsPrintableAlongWithPrintType));
                    target.printableAlongWithPrintType = null;
                    if (mergedPrintableAlongWithPrintType!= null) {
                        List<Reference> uniquePrintableAlongWithPrintTypel = target.getPrintableAlongWithPrintType();
                        uniquePrintableAlongWithPrintTypel.addAll(mergedPrintableAlongWithPrintType);
                    }
                }
            }
        }

        public PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes withPrintableAlongWithPrintType(Reference... values) {
            if (values!= null) {
                for (Reference value: values) {
                    getPrintableAlongWithPrintType().add(value);
                }
            }
            return this;
        }

        public PrintTypeRestrictionsDTO.PrintableAlongWithPrintTypes withPrintableAlongWithPrintType(Collection<Reference> values) {
            if (values!= null) {
                getPrintableAlongWithPrintType().addAll(values);
            }
            return this;
        }

    }

}
