//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.4 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2011.10.19 at 07:09:03 PM CEST 
//


package biz.company.api;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlType;
import org.jvnet.jaxb2_commons.lang.CopyStrategy;
import org.jvnet.jaxb2_commons.lang.CopyTo;
import org.jvnet.jaxb2_commons.lang.Equals;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy;
import org.jvnet.jaxb2_commons.lang.HashCode;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBCopyStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBMergeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBToStringStrategy;
import org.jvnet.jaxb2_commons.lang.MergeFrom;
import org.jvnet.jaxb2_commons.lang.MergeStrategy;
import org.jvnet.jaxb2_commons.lang.ToString;
import org.jvnet.jaxb2_commons.lang.ToStringStrategy;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;


/**
 * <p>Java class for designRestrictionsDTO complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="designRestrictionsDTO">
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element name="fixedColors" type="{http://www.w3.org/2001/XMLSchema}boolean"/>
 *         &lt;element name="ownText" type="{http://www.w3.org/2001/XMLSchema}boolean"/>
 *         &lt;element name="obligatory" type="{http://www.w3.org/2001/XMLSchema}boolean"/>
 *         &lt;element name="movable" type="{http://www.w3.org/2001/XMLSchema}boolean"/>
 *         &lt;element name="targetView" type="{http://www.w3.org/2001/XMLSchema}int"/>
 *         &lt;element name="minimumScale" type="{http://www.w3.org/2001/XMLSchema}int"/>
 *         &lt;element name="visible" type="{http://www.w3.org/2001/XMLSchema}boolean"/>
 *         &lt;element name="inverted" type="{http://www.w3.org/2001/XMLSchema}boolean"/>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "designRestrictionsDTO", propOrder = {
    "fixedColors",
    "ownText",
    "obligatory",
    "movable",
    "targetView",
    "minimumScale",
    "visible",
    "inverted"
})
public class DesignRestrictionsDTO
    implements Cloneable, CopyTo, Equals, HashCode, MergeFrom, ToString
{

    protected boolean fixedColors;
    protected boolean ownText;
    protected boolean obligatory;
    protected boolean movable;
    protected int targetView;
    protected int minimumScale;
    protected boolean visible;
    protected boolean inverted;

    /**
     * Gets the value of the fixedColors property.
     * 
     */
    public boolean isFixedColors() {
        return fixedColors;
    }

    /**
     * Sets the value of the fixedColors property.
     * 
     */
    public void setFixedColors(boolean value) {
        this.fixedColors = value;
    }

    /**
     * Gets the value of the ownText property.
     * 
     */
    public boolean isOwnText() {
        return ownText;
    }

    /**
     * Sets the value of the ownText property.
     * 
     */
    public void setOwnText(boolean value) {
        this.ownText = value;
    }

    /**
     * Gets the value of the obligatory property.
     * 
     */
    public boolean isObligatory() {
        return obligatory;
    }

    /**
     * Sets the value of the obligatory property.
     * 
     */
    public void setObligatory(boolean value) {
        this.obligatory = value;
    }

    /**
     * Gets the value of the movable property.
     * 
     */
    public boolean isMovable() {
        return movable;
    }

    /**
     * Sets the value of the movable property.
     * 
     */
    public void setMovable(boolean value) {
        this.movable = value;
    }

    /**
     * Gets the value of the targetView property.
     * 
     */
    public int getTargetView() {
        return targetView;
    }

    /**
     * Sets the value of the targetView property.
     * 
     */
    public void setTargetView(int value) {
        this.targetView = value;
    }

    /**
     * Gets the value of the minimumScale property.
     * 
     */
    public int getMinimumScale() {
        return minimumScale;
    }

    /**
     * Sets the value of the minimumScale property.
     * 
     */
    public void setMinimumScale(int value) {
        this.minimumScale = value;
    }

    /**
     * Gets the value of the visible property.
     * 
     */
    public boolean isVisible() {
        return visible;
    }

    /**
     * Sets the value of the visible property.
     * 
     */
    public void setVisible(boolean value) {
        this.visible = value;
    }

    /**
     * Gets the value of the inverted property.
     * 
     */
    public boolean isInverted() {
        return inverted;
    }

    /**
     * Sets the value of the inverted property.
     * 
     */
    public void setInverted(boolean value) {
        this.inverted = value;
    }

    public String toString() {
        final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        {
            boolean theFixedColors;
            theFixedColors = (true?this.isFixedColors():false);
            strategy.appendField(locator, this, "fixedColors", buffer, theFixedColors);
        }
        {
            boolean theOwnText;
            theOwnText = (true?this.isOwnText():false);
            strategy.appendField(locator, this, "ownText", buffer, theOwnText);
        }
        {
            boolean theObligatory;
            theObligatory = (true?this.isObligatory():false);
            strategy.appendField(locator, this, "obligatory", buffer, theObligatory);
        }
        {
            boolean theMovable;
            theMovable = (true?this.isMovable():false);
            strategy.appendField(locator, this, "movable", buffer, theMovable);
        }
        {
            int theTargetView;
            theTargetView = (true?this.getTargetView(): 0);
            strategy.appendField(locator, this, "targetView", buffer, theTargetView);
        }
        {
            int theMinimumScale;
            theMinimumScale = (true?this.getMinimumScale(): 0);
            strategy.appendField(locator, this, "minimumScale", buffer, theMinimumScale);
        }
        {
            boolean theVisible;
            theVisible = (true?this.isVisible():false);
            strategy.appendField(locator, this, "visible", buffer, theVisible);
        }
        {
            boolean theInverted;
            theInverted = (true?this.isInverted():false);
            strategy.appendField(locator, this, "inverted", buffer, theInverted);
        }
        return buffer;
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
        if (!(object instanceof DesignRestrictionsDTO)) {
            return false;
        }
        if (this == object) {
            return true;
        }
        final DesignRestrictionsDTO that = ((DesignRestrictionsDTO) object);
        {
            boolean lhsFixedColors;
            lhsFixedColors = (true?this.isFixedColors():false);
            boolean rhsFixedColors;
            rhsFixedColors = (true?that.isFixedColors():false);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "fixedColors", lhsFixedColors), LocatorUtils.property(thatLocator, "fixedColors", rhsFixedColors), lhsFixedColors, rhsFixedColors)) {
                return false;
            }
        }
        {
            boolean lhsOwnText;
            lhsOwnText = (true?this.isOwnText():false);
            boolean rhsOwnText;
            rhsOwnText = (true?that.isOwnText():false);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "ownText", lhsOwnText), LocatorUtils.property(thatLocator, "ownText", rhsOwnText), lhsOwnText, rhsOwnText)) {
                return false;
            }
        }
        {
            boolean lhsObligatory;
            lhsObligatory = (true?this.isObligatory():false);
            boolean rhsObligatory;
            rhsObligatory = (true?that.isObligatory():false);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "obligatory", lhsObligatory), LocatorUtils.property(thatLocator, "obligatory", rhsObligatory), lhsObligatory, rhsObligatory)) {
                return false;
            }
        }
        {
            boolean lhsMovable;
            lhsMovable = (true?this.isMovable():false);
            boolean rhsMovable;
            rhsMovable = (true?that.isMovable():false);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "movable", lhsMovable), LocatorUtils.property(thatLocator, "movable", rhsMovable), lhsMovable, rhsMovable)) {
                return false;
            }
        }
        {
            int lhsTargetView;
            lhsTargetView = (true?this.getTargetView(): 0);
            int rhsTargetView;
            rhsTargetView = (true?that.getTargetView(): 0);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "targetView", lhsTargetView), LocatorUtils.property(thatLocator, "targetView", rhsTargetView), lhsTargetView, rhsTargetView)) {
                return false;
            }
        }
        {
            int lhsMinimumScale;
            lhsMinimumScale = (true?this.getMinimumScale(): 0);
            int rhsMinimumScale;
            rhsMinimumScale = (true?that.getMinimumScale(): 0);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "minimumScale", lhsMinimumScale), LocatorUtils.property(thatLocator, "minimumScale", rhsMinimumScale), lhsMinimumScale, rhsMinimumScale)) {
                return false;
            }
        }
        {
            boolean lhsVisible;
            lhsVisible = (true?this.isVisible():false);
            boolean rhsVisible;
            rhsVisible = (true?that.isVisible():false);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "visible", lhsVisible), LocatorUtils.property(thatLocator, "visible", rhsVisible), lhsVisible, rhsVisible)) {
                return false;
            }
        }
        {
            boolean lhsInverted;
            lhsInverted = (true?this.isInverted():false);
            boolean rhsInverted;
            rhsInverted = (true?that.isInverted():false);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "inverted", lhsInverted), LocatorUtils.property(thatLocator, "inverted", rhsInverted), lhsInverted, rhsInverted)) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
        int currentHashCode = 1;
        {
            boolean theFixedColors;
            theFixedColors = (true?this.isFixedColors():false);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "fixedColors", theFixedColors), currentHashCode, theFixedColors);
        }
        {
            boolean theOwnText;
            theOwnText = (true?this.isOwnText():false);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "ownText", theOwnText), currentHashCode, theOwnText);
        }
        {
            boolean theObligatory;
            theObligatory = (true?this.isObligatory():false);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "obligatory", theObligatory), currentHashCode, theObligatory);
        }
        {
            boolean theMovable;
            theMovable = (true?this.isMovable():false);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "movable", theMovable), currentHashCode, theMovable);
        }
        {
            int theTargetView;
            theTargetView = (true?this.getTargetView(): 0);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "targetView", theTargetView), currentHashCode, theTargetView);
        }
        {
            int theMinimumScale;
            theMinimumScale = (true?this.getMinimumScale(): 0);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "minimumScale", theMinimumScale), currentHashCode, theMinimumScale);
        }
        {
            boolean theVisible;
            theVisible = (true?this.isVisible():false);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "visible", theVisible), currentHashCode, theVisible);
        }
        {
            boolean theInverted;
            theInverted = (true?this.isInverted():false);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "inverted", theInverted), currentHashCode, theInverted);
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

    public Object clone() {
        return copyTo(createNewInstance());
    }

    public Object copyTo(Object target) {
        final CopyStrategy strategy = JAXBCopyStrategy.INSTANCE;
        return copyTo(null, target, strategy);
    }

    public Object copyTo(ObjectLocator locator, Object target, CopyStrategy strategy) {
        final Object draftCopy = ((target == null)?createNewInstance():target);
        if (draftCopy instanceof DesignRestrictionsDTO) {
            final DesignRestrictionsDTO copy = ((DesignRestrictionsDTO) draftCopy);
            boolean sourceFixedColors;
            sourceFixedColors = (true?this.isFixedColors():false);
            boolean copyFixedColors = strategy.copy(LocatorUtils.property(locator, "fixedColors", sourceFixedColors), sourceFixedColors);
            copy.setFixedColors(copyFixedColors);
            boolean sourceOwnText;
            sourceOwnText = (true?this.isOwnText():false);
            boolean copyOwnText = strategy.copy(LocatorUtils.property(locator, "ownText", sourceOwnText), sourceOwnText);
            copy.setOwnText(copyOwnText);
            boolean sourceObligatory;
            sourceObligatory = (true?this.isObligatory():false);
            boolean copyObligatory = strategy.copy(LocatorUtils.property(locator, "obligatory", sourceObligatory), sourceObligatory);
            copy.setObligatory(copyObligatory);
            boolean sourceMovable;
            sourceMovable = (true?this.isMovable():false);
            boolean copyMovable = strategy.copy(LocatorUtils.property(locator, "movable", sourceMovable), sourceMovable);
            copy.setMovable(copyMovable);
            int sourceTargetView;
            sourceTargetView = (true?this.getTargetView(): 0);
            int copyTargetView = strategy.copy(LocatorUtils.property(locator, "targetView", sourceTargetView), sourceTargetView);
            copy.setTargetView(copyTargetView);
            int sourceMinimumScale;
            sourceMinimumScale = (true?this.getMinimumScale(): 0);
            int copyMinimumScale = strategy.copy(LocatorUtils.property(locator, "minimumScale", sourceMinimumScale), sourceMinimumScale);
            copy.setMinimumScale(copyMinimumScale);
            boolean sourceVisible;
            sourceVisible = (true?this.isVisible():false);
            boolean copyVisible = strategy.copy(LocatorUtils.property(locator, "visible", sourceVisible), sourceVisible);
            copy.setVisible(copyVisible);
            boolean sourceInverted;
            sourceInverted = (true?this.isInverted():false);
            boolean copyInverted = strategy.copy(LocatorUtils.property(locator, "inverted", sourceInverted), sourceInverted);
            copy.setInverted(copyInverted);
        }
        return draftCopy;
    }

    public Object createNewInstance() {
        return new DesignRestrictionsDTO();
    }

    public void mergeFrom(Object left, Object right) {
        final MergeStrategy strategy = JAXBMergeStrategy.INSTANCE;
        mergeFrom(null, null, left, right, strategy);
    }

    public void mergeFrom(ObjectLocator leftLocator, ObjectLocator rightLocator, Object left, Object right, MergeStrategy strategy) {
        if (right instanceof DesignRestrictionsDTO) {
            final DesignRestrictionsDTO target = this;
            final DesignRestrictionsDTO leftObject = ((DesignRestrictionsDTO) left);
            final DesignRestrictionsDTO rightObject = ((DesignRestrictionsDTO) right);
            {
                boolean lhsFixedColors;
                lhsFixedColors = (true?leftObject.isFixedColors():false);
                boolean rhsFixedColors;
                rhsFixedColors = (true?rightObject.isFixedColors():false);
                boolean mergedFixedColors = ((boolean) strategy.merge(LocatorUtils.property(leftLocator, "fixedColors", lhsFixedColors), LocatorUtils.property(rightLocator, "fixedColors", rhsFixedColors), lhsFixedColors, rhsFixedColors));
                target.setFixedColors(mergedFixedColors);
            }
            {
                boolean lhsOwnText;
                lhsOwnText = (true?leftObject.isOwnText():false);
                boolean rhsOwnText;
                rhsOwnText = (true?rightObject.isOwnText():false);
                boolean mergedOwnText = ((boolean) strategy.merge(LocatorUtils.property(leftLocator, "ownText", lhsOwnText), LocatorUtils.property(rightLocator, "ownText", rhsOwnText), lhsOwnText, rhsOwnText));
                target.setOwnText(mergedOwnText);
            }
            {
                boolean lhsObligatory;
                lhsObligatory = (true?leftObject.isObligatory():false);
                boolean rhsObligatory;
                rhsObligatory = (true?rightObject.isObligatory():false);
                boolean mergedObligatory = ((boolean) strategy.merge(LocatorUtils.property(leftLocator, "obligatory", lhsObligatory), LocatorUtils.property(rightLocator, "obligatory", rhsObligatory), lhsObligatory, rhsObligatory));
                target.setObligatory(mergedObligatory);
            }
            {
                boolean lhsMovable;
                lhsMovable = (true?leftObject.isMovable():false);
                boolean rhsMovable;
                rhsMovable = (true?rightObject.isMovable():false);
                boolean mergedMovable = ((boolean) strategy.merge(LocatorUtils.property(leftLocator, "movable", lhsMovable), LocatorUtils.property(rightLocator, "movable", rhsMovable), lhsMovable, rhsMovable));
                target.setMovable(mergedMovable);
            }
            {
                int lhsTargetView;
                lhsTargetView = (true?leftObject.getTargetView(): 0);
                int rhsTargetView;
                rhsTargetView = (true?rightObject.getTargetView(): 0);
                int mergedTargetView = ((int) strategy.merge(LocatorUtils.property(leftLocator, "targetView", lhsTargetView), LocatorUtils.property(rightLocator, "targetView", rhsTargetView), lhsTargetView, rhsTargetView));
                target.setTargetView(mergedTargetView);
            }
            {
                int lhsMinimumScale;
                lhsMinimumScale = (true?leftObject.getMinimumScale(): 0);
                int rhsMinimumScale;
                rhsMinimumScale = (true?rightObject.getMinimumScale(): 0);
                int mergedMinimumScale = ((int) strategy.merge(LocatorUtils.property(leftLocator, "minimumScale", lhsMinimumScale), LocatorUtils.property(rightLocator, "minimumScale", rhsMinimumScale), lhsMinimumScale, rhsMinimumScale));
                target.setMinimumScale(mergedMinimumScale);
            }
            {
                boolean lhsVisible;
                lhsVisible = (true?leftObject.isVisible():false);
                boolean rhsVisible;
                rhsVisible = (true?rightObject.isVisible():false);
                boolean mergedVisible = ((boolean) strategy.merge(LocatorUtils.property(leftLocator, "visible", lhsVisible), LocatorUtils.property(rightLocator, "visible", rhsVisible), lhsVisible, rhsVisible));
                target.setVisible(mergedVisible);
            }
            {
                boolean lhsInverted;
                lhsInverted = (true?leftObject.isInverted():false);
                boolean rhsInverted;
                rhsInverted = (true?rightObject.isInverted():false);
                boolean mergedInverted = ((boolean) strategy.merge(LocatorUtils.property(leftLocator, "inverted", lhsInverted), LocatorUtils.property(rightLocator, "inverted", rhsInverted), lhsInverted, rhsInverted));
                target.setInverted(mergedInverted);
            }
        }
    }

    public DesignRestrictionsDTO withFixedColors(boolean value) {
        setFixedColors(value);
        return this;
    }

    public DesignRestrictionsDTO withOwnText(boolean value) {
        setOwnText(value);
        return this;
    }

    public DesignRestrictionsDTO withObligatory(boolean value) {
        setObligatory(value);
        return this;
    }

    public DesignRestrictionsDTO withMovable(boolean value) {
        setMovable(value);
        return this;
    }

    public DesignRestrictionsDTO withTargetView(int value) {
        setTargetView(value);
        return this;
    }

    public DesignRestrictionsDTO withMinimumScale(int value) {
        setMinimumScale(value);
        return this;
    }

    public DesignRestrictionsDTO withVisible(boolean value) {
        setVisible(value);
        return this;
    }

    public DesignRestrictionsDTO withInverted(boolean value) {
        setInverted(value);
        return this;
    }

}
